#!/bin/bash
#
# Network Repair Utility
# Fix network configuration and connectivity issues
#

set -e

RED='\033[0;31m'
GREEN='\033[0;32m'
YELLOW='\033[1;33m'
BLUE='\033[0;34m'
BOLD='\033[1m'
NC='\033[0m'

log_message() {
    local level=$1
    local message=$2
    
    case $level in
        "INFO") echo -e "${BLUE}[INFO]${NC} $message" ;;
        "SUCCESS") echo -e "${GREEN}[SUCCESS]${NC} $message" ;;
        "WARNING") echo -e "${YELLOW}[WARNING]${NC} $message" ;;
        "ERROR") echo -e "${RED}[ERROR]${NC} $message" ;;
    esac
}

restart_network_services() {
    log_message "INFO" "Restarting network services..."
    
    local services=("NetworkManager" "systemd-networkd" "networking")
    
    for service in "${services[@]}"; do
        if systemctl list-unit-files | grep -q "^$service"; then
            log_message "INFO" "Restarting $service..."
            if sudo systemctl restart "$service" 2>/dev/null; then
                log_message "SUCCESS" "$service restarted"
            else
                log_message "WARNING" "Failed to restart $service"
            fi
        fi
    done
    
    # Wait for services to stabilize
    sleep 3
}

reset_network_interfaces() {
    log_message "INFO" "Resetting network interfaces..."
    
    for interface in $(ip link show | grep -E "^[0-9]+:" | awk -F': ' '{print $2}' | cut -d'@' -f1 | grep -v lo); do
        log_message "INFO" "Resetting interface $interface..."
        
        # Release DHCP lease if any
        sudo dhclient -r "$interface" 2>/dev/null || true
        
        # Bring interface down and up
        sudo ip link set "$interface" down 2>/dev/null || true
        sleep 1
        sudo ip link set "$interface" up 2>/dev/null || true
        
        # Request new DHCP lease
        sudo dhclient "$interface" 2>/dev/null &
        
        log_message "SUCCESS" "Interface $interface reset"
    done
    
    # Wait for DHCP
    sleep 5
}

fix_dns_configuration() {
    log_message "INFO" "Fixing DNS configuration..."
    
    # Backup current resolv.conf
    if [ -f /etc/resolv.conf ]; then
        sudo cp /etc/resolv.conf /etc/resolv.conf.backup.$(date +%s)
        log_message "INFO" "Backed up current DNS configuration"
    fi
    
    # Create new resolv.conf with reliable DNS servers
    sudo tee /etc/resolv.conf > /dev/null << 'EOF'
# Generated by Linux Rescue Drive
nameserver 8.8.8.8
nameserver 8.8.4.4
nameserver 1.1.1.1
nameserver 1.0.0.1
options timeout:2
options attempts:3
options rotate
EOF
    
    log_message "SUCCESS" "DNS configuration updated with reliable servers"
    
    # Test DNS resolution
    if nslookup google.com >/dev/null 2>&1; then
        log_message "SUCCESS" "DNS resolution is working"
    else
        log_message "WARNING" "DNS resolution still not working"
        
        # Try alternative DNS configuration
        sudo tee /etc/resolv.conf > /dev/null << 'EOF'
nameserver 208.67.222.222
nameserver 208.67.220.220
EOF
        log_message "INFO" "Trying alternative DNS servers"
        
        if nslookup google.com >/dev/null 2>&1; then
            log_message "SUCCESS" "DNS resolution working with alternative servers"
        fi
    fi
}

configure_static_ip() {
    log_message "INFO" "Configuring static IP address..."
    
    echo "Available network interfaces:"
    ip link show | grep -E "^[0-9]+:" | while read line; do
        local interface=$(echo "$line" | awk -F': ' '{print $2}' | cut -d'@' -f1)
        local state=$(echo "$line" | grep -o "state [A-Z]*" | awk '{print $2}')
        echo "  $interface ($state)"
    done
    echo
    
    read -p "Enter interface name: " interface
    read -p "Enter IP address (e.g., 192.168.1.100): " ip_addr
    read -p "Enter subnet mask (e.g., 24): " netmask
    read -p "Enter gateway IP (e.g., 192.168.1.1): " gateway
    
    # Validate interface
    if ! ip link show "$interface" >/dev/null 2>&1; then
        log_message "ERROR" "Interface $interface does not exist"
        return 1
    fi
    
    log_message "INFO" "Configuring static IP on $interface..."
    
    # Remove any existing IP addresses
    sudo ip addr flush dev "$interface"
    
    # Add new IP address
    if sudo ip addr add "$ip_addr/$netmask" dev "$interface"; then
        log_message "SUCCESS" "IP address configured: $ip_addr/$netmask"
    else
        log_message "ERROR" "Failed to configure IP address"
        return 1
    fi
    
    # Add default route
    if sudo ip route add default via "$gateway" dev "$interface"; then
        log_message "SUCCESS" "Default route configured: $gateway"
    else
        log_message "WARNING" "Failed to configure default route"
    fi
    
    # Test connectivity
    if ping -c 1 -W 5 "$gateway" >/dev/null 2>&1; then
        log_message "SUCCESS" "Gateway is reachable"
    else
        log_message "WARNING" "Gateway is not reachable"
    fi
    
    if ping -c 1 -W 5 8.8.8.8 >/dev/null 2>&1; then
        log_message "SUCCESS" "Internet connectivity established"
    else
        log_message "WARNING" "No internet connectivity"
    fi
}

scan_wifi_networks() {
    log_message "INFO" "Scanning for WiFi networks..."
    
    # Find WiFi interfaces
    local wifi_interfaces=()
    for interface in $(iw dev 2>/dev/null | awk '/Interface/ {print $2}'); do
        wifi_interfaces+=("$interface")
    done
    
    if [ ${#wifi_interfaces[@]} -eq 0 ]; then
        log_message "WARNING" "No WiFi interfaces found"
        return 1
    fi
    
    echo "WiFi interfaces found:"
    for interface in "${wifi_interfaces[@]}"; do
        echo "  $interface"
    done
    echo
    
    # Select interface
    local selected_interface="${wifi_interfaces[0]}"
    if [ ${#wifi_interfaces[@]} -gt 1 ]; then
        read -p "Select WiFi interface [${selected_interface}]: " user_interface
        if [ -n "$user_interface" ]; then
            selected_interface="$user_interface"
        fi
    fi
    
    log_message "INFO" "Scanning networks on $selected_interface..."
    
    # Bring interface up
    sudo ip link set "$selected_interface" up 2>/dev/null || true
    
    # Scan for networks
    if sudo iw dev "$selected_interface" scan 2>/dev/null | grep -E "SSID|signal" | while read line; do
        if echo "$line" | grep -q "SSID:"; then
            local ssid=$(echo "$line" | sed 's/.*SSID: //')
            if [ -n "$ssid" ]; then
                echo "Network: $ssid"
            fi
        elif echo "$line" | grep -q "signal:"; then
            local signal=$(echo "$line" | awk '{print $2}' | sed 's/signal://')
            echo "  Signal: $signal dBm"
        fi
    done; then
        log_message "SUCCESS" "WiFi scan completed"
    else
        log_message "WARNING" "WiFi scan failed or no networks found"
    fi
}

fix_firewall_rules() {
    log_message "INFO" "Checking firewall configuration..."
    
    # Check if ufw is installed and active
    if command -v ufw >/dev/null 2>&1; then
        local ufw_status=$(sudo ufw status | head -1)
        log_message "INFO" "UFW status: $ufw_status"
        
        if echo "$ufw_status" | grep -q "inactive"; then
            log_message "INFO" "UFW is inactive"
        else
            echo "UFW rules:"
            sudo ufw status numbered
            echo
            
            echo "Reset UFW to defaults? (y/N): "
            read -n 1 reset_ufw
            echo
            
            if [[ $reset_ufw =~ ^[Yy]$ ]]; then
                log_message "INFO" "Resetting UFW to defaults..."
                sudo ufw --force reset
                sudo ufw default deny incoming
                sudo ufw default allow outgoing
                log_message "SUCCESS" "UFW reset to secure defaults"
            fi
        fi
    fi
    
    # Check iptables rules
    if command -v iptables >/dev/null 2>&1; then
        local iptables_rules=$(sudo iptables -L | wc -l)
        if [ "$iptables_rules" -gt 10 ]; then
            log_message "INFO" "Custom iptables rules detected ($iptables_rules lines)"
            
            echo "View iptables rules? (y/N): "
            read -n 1 view_iptables
            echo
            
            if [[ $view_iptables =~ ^[Yy]$ ]]; then
                sudo iptables -L -n --line-numbers | less
            fi
            
            echo "Flush iptables rules? (y/N): "
            read -n 1 flush_iptables
            echo
            
            if [[ $flush_iptables =~ ^[Yy]$ ]]; then
                log_message "INFO" "Flushing iptables rules..."
                sudo iptables -F
                sudo iptables -X
                sudo iptables -t nat -F
                sudo iptables -t nat -X
                log_message "SUCCESS" "Iptables rules flushed"
            fi
        else
            log_message "SUCCESS" "Iptables rules appear to be default"
        fi
    fi
}

test_network_connectivity() {
    log_message "INFO" "Testing network connectivity..."
    
    # Test local interface connectivity
    echo -e "${BOLD}Interface Status:${NC}"
    for interface in $(ip link show | grep -E "^[0-9]+:" | awk -F': ' '{print $2}' | cut -d'@' -f1 | grep -v lo); do
        local ip_addr=$(ip addr show "$interface" | grep "inet " | awk '{print $2}' | head -1)
        local state=$(ip link show "$interface" | grep -o "state [A-Z]*" | awk '{print $2}')
        
        if [ -n "$ip_addr" ]; then
            echo "  $interface: $state, IP: $ip_addr"
        else
            echo "  $interface: $state, No IP"
        fi
    done
    echo
    
    # Test gateway connectivity
    echo -e "${BOLD}Gateway Connectivity:${NC}"
    local gateways=$(ip route | grep default | awk '{print $3}' | sort -u)
    for gateway in $gateways; do
        if ping -c 1 -W 5 "$gateway" >/dev/null 2>&1; then
            log_message "SUCCESS" "Gateway $gateway is reachable"
        else
            log_message "ERROR" "Gateway $gateway is not reachable"
        fi
    done
    echo
    
    # Test DNS resolution
    echo -e "${BOLD}DNS Resolution:${NC}"
    local test_domains=("google.com" "cloudflare.com" "github.com")
    for domain in "${test_domains[@]}"; do
        if nslookup "$domain" >/dev/null 2>&1; then
            log_message "SUCCESS" "DNS resolution for $domain: OK"
        else
            log_message "ERROR" "DNS resolution for $domain: FAILED"
        fi
    done
    echo
    
    # Test internet connectivity
    echo -e "${BOLD}Internet Connectivity:${NC}"
    local test_ips=("8.8.8.8" "1.1.1.1" "208.67.222.222")
    for ip in "${test_ips[@]}"; do
        if ping -c 1 -W 5 "$ip" >/dev/null 2>&1; then
            log_message "SUCCESS" "Ping to $ip: OK"
        else
            log_message "ERROR" "Ping to $ip: FAILED"
        fi
    done
    
    # Test HTTP connectivity
    if command -v curl >/dev/null 2>&1; then
        if curl -s --connect-timeout 5 http://httpbin.org/ip >/dev/null 2>&1; then
            log_message "SUCCESS" "HTTP connectivity: OK"
        else
            log_message "ERROR" "HTTP connectivity: FAILED"
        fi
        
        if curl -s --connect-timeout 5 https://httpbin.org/ip >/dev/null 2>&1; then
            log_message "SUCCESS" "HTTPS connectivity: OK"
        else
            log_message "ERROR" "HTTPS connectivity: FAILED"
        fi
    fi
}

interactive_network_repair() {
    echo -e "${BOLD}Network Repair Utility${NC}"
    echo
    
    echo "Select network repair option:"
    echo "1) Test network connectivity"
    echo "2) Restart network services"
    echo "3) Reset network interfaces"
    echo "4) Fix DNS configuration"
    echo "5) Configure static IP"
    echo "6) Scan WiFi networks"
    echo "7) Check firewall rules"
    echo "8) Complete network reset"
    echo "9) Network diagnostics"
    echo
    
    read -p "Select option (1-9): " repair_option
    
    case $repair_option in
        1) test_network_connectivity ;;
        2) restart_network_services ;;
        3) reset_network_interfaces ;;
        4) fix_dns_configuration ;;
        5) configure_static_ip ;;
        6) scan_wifi_networks ;;
        7) fix_firewall_rules ;;
        8)
            log_message "INFO" "Performing complete network reset..."
            restart_network_services
            reset_network_interfaces
            fix_dns_configuration
            test_network_connectivity
            ;;
        9)
            echo -e "${BOLD}Network Diagnostics:${NC}"
            echo
            echo "Network interfaces:"
            ip link show
            echo
            echo "IP addresses:"
            ip addr show
            echo
            echo "Routing table:"
            ip route show
            echo
            echo "DNS configuration:"
            cat /etc/resolv.conf
            echo
            echo "Network statistics:"
            ss -tuln | head -20
            ;;
        *)
            log_message "ERROR" "Invalid option"
            return 1
            ;;
    esac
}

main() {
    interactive_network_repair
}

main "$@"